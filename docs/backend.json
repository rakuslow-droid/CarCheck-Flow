{
  "entities": {
    "Merchant": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Merchant",
      "type": "object",
      "description": "Represents a car shop or merchant registered in the system, typically managed via LINE messaging and a web interface.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Merchant entity (merchantId)."
        },
        "displayName": {
          "type": "string",
          "description": "The public-facing name of the car shop or merchant."
        },
        "lineAccessToken": {
          "type": "string",
          "description": "LINE Messaging API access token for this merchant. (Security Note: Handle this token with extreme care; it grants access to send messages on behalf of the merchant.)"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp when the merchant record was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "displayName",
        "lineAccessToken",
        "createdAt"
      ]
    },
    "Vehicle": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Vehicle",
      "type": "object",
      "description": "Represents a vehicle and its inspection data, linked to a specific merchant and LINE user, used for inspection reminders.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Vehicle entity (vehicleId)."
        },
        "merchantId": {
          "type": "string",
          "description": "Reference to the Merchant who manages this vehicle. (Relationship: Merchant 1:N Vehicle)"
        },
        "lineUserId": {
          "type": "string",
          "description": "Unique identifier for the LINE user who owns or is associated with this vehicle."
        },
        "inspectionDate": {
          "type": "string",
          "description": "The vehicle inspection date extracted from the certificate or sticker.",
          "format": "date"
        },
        "status": {
          "type": "string",
          "description": "Current status of the vehicle's inspection process (e.g., 'pending', 'processed', 'reminded', 'completed')."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL to the uploaded vehicle inspection certificate image stored in Firebase Storage.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "merchantId",
        "lineUserId",
        "inspectionDate",
        "status",
        "imageUrl"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/merchants/{merchantId}",
        "definition": {
          "entityName": "Merchant",
          "schema": {
            "$ref": "#/backend/entities/Merchant"
          },
          "description": "Stores merchant details. Each document represents a single car shop. Includes denormalized 'ownerUserId' (string, Firebase Auth UID) for authorization, linking the merchant to a specific Firebase Auth user who manages it via the web interface.",
          "params": [
            {
              "name": "merchantId",
              "description": "Unique identifier for the Merchant entity."
            }
          ]
        }
      },
      {
        "path": "/vehicles/{vehicleId}",
        "definition": {
          "entityName": "Vehicle",
          "schema": {
            "$ref": "#/backend/entities/Vehicle"
          },
          "description": "Stores vehicle inspection data. Each document represents a single vehicle associated with a merchant and a LINE user. Includes denormalized 'merchantOwnerId' (string, Firebase Auth UID) for authorization, which is copied from the associated merchant's ownerUserId, to enable direct access control for web users without requiring cross-document reads.",
          "params": [
            {
              "name": "vehicleId",
              "description": "Unique identifier for the Vehicle entity."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to adhere strictly to the core principles of Authorization Independence, Structural Segregation, and Access Modeling, ensuring a secure, scalable, and easily debuggable system for CarCheck-Flow. \n\n**Authorization Independence (CRITICAL) & Denormalization:**\nTo eliminate the need for costly and complex `get()` calls in security rules, authorization context is denormalized directly into the documents. \n- For the `/merchants` collection, each `Merchant` document will include an `ownerUserId` field. This field stores the Firebase Auth UID of the user responsible for managing that specific merchant via the web interface. This denormalization allows rules to directly check `request.auth.uid == resource.data.ownerUserId` for access to merchant data, ensuring atomic operations and simplified rule logic.\n- For the `/vehicles` collection, each `Vehicle` document will include a `merchantOwnerId` field. This field is a copy of the `ownerUserId` from the `Merchant` associated with the vehicle. This critical denormalization allows web interface users (authenticated by `request.auth.uid`) to directly query and access their respective vehicles using `request.auth.uid == resource.data.merchantOwnerId` without needing to perform a `get()` call to the parent `Merchant` document. This directly addresses the Authorization Independence mandate by pushing the necessary authorization data to the leaf node, simplifying rules and improving performance.\n\n**QAPs (Rules are not Filters) & Structural Segregation:**\n- **Structural Segregation:** Both `/merchants` and `/vehicles` collections maintain a homogeneous security posture. All documents within `/merchants` are governed by the `ownerUserId`, and all documents within `/vehicles` are governed by `merchantOwnerId`. There's no mixing of publicly accessible data with private data within the same collection, simplifying rule sets.\n- **Query-Based Access (QAPs):** For secure `list` operations, client applications are required to include specific authorization filters in their queries. For example:\n    - To list merchants, a web user's query must include `where('ownerUserId', '==', request.auth.uid)`. The security rules will then ensure that only authenticated users querying for their *own* `ownerUserId` can perform the `list` operation, preventing data leakage.\n    - To list vehicles, a web user's query must include `where('merchantOwnerId', '==', request.auth.uid)`. Similar to merchants, rules enforce that only an authenticated user can list vehicles associated with the merchant they manage.\nThis approach ensures that security rules are not used as data filters after the fact, but rather enforce that queries are inherently secure and scoped to the user's permissions.\n\n**Access Modeling & Data Clarity:**\n- **Path-Based Ownership:** While not strictly hierarchical in terms of subcollections, the data structure uses top-level collections (`/merchants`, `/vehicles`) with explicit `ownerUserId`/`merchantOwnerId` fields for clear, explicit ownership, which functions similarly to path-based ownership in terms of rule simplicity.\n- **Explicit State Modeling:** The `status` field in the `Vehicle` entity allows for clear state tracking (e.g., 'pending', 'processed'), improving debuggability and predictability. \n- **Radical Consistency:** Consistent naming conventions like `merchantId`, `vehicleId`, `ownerUserId`, `merchantOwnerId` are used, making the data structure intuitive and maintainable."
  }
}